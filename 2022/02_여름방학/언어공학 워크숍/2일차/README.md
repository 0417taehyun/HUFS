# 2일차: 비선형 자료 구조 트리(Tree)

## 목차

- [학습 목표](#학습-목표)
- [선형 자료 구조: 큐(Queue)](#선형-자료-구조-큐queue)
  - [정의](#정의)
  - [구조](#구조)
  - [연산](#연산)
  - [구현](#구현)
  - [응용 분야](#응용-분야)
- [비선형 자료 구조: 트리(Tree)](#비선형-자료구조-트리tree)
  - [정의](#정의-1)
  - [응용 분야](#응용-분야-1)
  - [용어](#용어)
- [이진 트리(Binary Tree)](#이진-트리binary-tree)
  - [정의](#정의-2)
  - [특징](#특징)
  - [종류](#종류)
- [실습](#실습)

### 학습 목표

- 선형 자료 구조 큐(Queue)
- 비선형 자료 구조 트리(Tree)

### 선형 자료 구조: 큐(Queue)

#### 정의

스택(Stack)과 마찬가지로 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트(List)다.

큐의 마지막에는 삽입만 가능하고 앞에는 삭제만 할 수 있는 구조로 일명 선입선출 구조, 다시 말해 FIFO(First In First Out) 구조이다.

쉽게 영화관 매표소에서 표를 구매하기 위에 줄 서있는 상황을 생각하면 된다.

#### 구조

가장 마지막에 들어온 데이터의 정보만 알고 있으면 되는 스택과 달리 가장 먼저 들어온 데이터와 가장 나중에 들어온 데이터의 정보를 가지고 있어야 한다.

#### 연산

삽입 연산(`enQueue`)과 삭제 연산(`deQueue`)이 존재한다.

#### 구현

##### Python 클래스와 리스트를 이용한 구현

```Python
class Queue:
    queue_size: int = 3

    def __init__(self) -> None:
        self.current_size: int = 0
        self.queue: list[int] = []

    def __call__(self) -> None:
        print(self.queue)

    def enqueue(self, value: int) -> None:
        if self.current_size == Queue.queue_size:
            print("Queue is full!")

        else:
            self.current_size += 1
            self.queue.append(value)
            print(f"{value} inserted")

    def dequeue(self) -> None:
        if self.current_size == 0:
            print("Queue is empty!")

        else:
            self.current_size -= 1
            element: int = self.queue.pop(0)
            print(f"{element} deleted")
```

#### 응용 분야

##### 프린터 버퍼 큐

- CPU에서 프린터로 보낸 데이터 순서대로 프린터에서 출력하기 위해 큐 자료 구조를 사용한다.

##### 스케줄링 큐

- CPU 사용을 요청한 프로세서들의 순서를 스케줄링하기 위해 큐 자료 구조를 사용한다.

### 비선형 자료구조: 트리(Tree)

#### 정의

원소들 간에 1:N 관계를 가지는 비선형 자료 구조이자 계층 관계를 가지는 계층형 자료 구조이다.

상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조라 트리(Tree)라 부른다.

쉽게 가족 구성원을 보여주는 가계도를 생각하면 된다.

#### 응용 분야

- 자료 탐색: 한국외대 조직도
- 의사 결정: 오늘 서울의 날씨
- 파일 시스: C드라이브의 용량
- 검색 엔진
- DBMS
- 라우터 알고리즘

#### 용어

##### 간선(Edge)

노드를 연결하는 선, 다시 말해 부모 노드와 자식 노드를 연결하는 선을 의미한다.

##### 노드(Node)

트리의 원소를 의미한다.

##### 루트 노드(Root Node)

트리의 시작 노드를 의미한다.

##### 부모 노드(Parent Node)

노드의 한 단계 상위 노드를 의미한다.

##### 자식 노드(Child Node)

노드의 한 단계 하위 노드들을 의미한다.

이때 유의할 점은 하나의 부모 노드는 여러 자식 노드를 가지지만 하나의 자식 노드는 하나의 부모 노드만 갖는다.

##### 형제 노드(Sibling Node)

동일한 부모 노드의 자식 노드들을 의미한다.

##### 조상 노드(Ancestor Node)

간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들을 의미한다.

##### 자손 노드(Descendant Node)

한 부모 노드를 기준으로 하위의 단말 노드까지의 모든 노드들을 의미한다.

##### 단말 노드(Leaf Node)

자식이 없는 노드를 의미한다.

##### 서브 트리(Sub Tree)

부모 노드와 연결된 간선을 끊었을 때 생성되는 트리이다.

각 노드는 자식 노드의 개수 만큼 서브 트리를 갖는다.

##### 차수(Degree)

노드의 차수와 트리의 차수가 있다.

노드의 차수는 노드에 연결된 자식 노드의 수를 의미하며 트리의 차수는 트리에 있는 노드의 차수 중 가장 큰 값을 의미한다.

##### 높이(Heigth)

루트 노드에서 가장 깊이 있는 노드까지 가는 경로의 길이를 의미한다.

노드에 대한 정보인 깊이(Depth)와 달리 하나의 트리에 해당하는 정보라 생각하면 된다.

따라서 루트 노드의 높이는 0이다.

##### 깊이(Depth)

루트 노드에서 특정 노드까지 가는 경로의 길이를 의미한다.

트리에 대한 정보인 높이(Height)와 달리 하나의 노드에 해당하는 정보라 생각하면 된다.

따라서 루트 노드의 깊이는 0이다.

### 이진 트리(Binary Tree)

#### 정의

트리의 노드 구조를 일정하게 정의하여 트리의 구현과 연산이 쉽도록 정의한 트리다.

이진 트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드 만을 가진다는 특징이 있다.

따라서 부모 노드와 자식 노드 수와의 관계는 1:2가 되고 특정 노드의 자식 노드의 수는 0보다 크거나 같으며 2보다 작거나 같아야 한다.

이때 중요한 건 이진 트리가 순환적 구성을 가진다는 점이다.

다시 말해 노드의 왼쪽 자식 노드를 루트로 하는 왼쪽 서브 트리도 이진 트리이며 오른쪽 자식 노드를 루트로 하는 오른쪽 서브 트리 또한 이진 트리가 된다.

이진 트리가 일반적인 트리보다 훨씬 효율적인 이유는 메모리 때문이다.

일반적인 트리의 경우 자식 노드의 개수에 제한이 없기 때문에 가장 최대의 자식 노드 개수 만큼, 다시 말해 트리의 차수 크기 만큼 각 노드에 메모리 공간이 할당되어야 한다.

하지만 이진 트리의 경우 최대 2개의 자식 노드만 가질 수 있기 때문에 메모리에 있어서 훨씬 효율적이다.

#### 특징

- N개의 노드를 가진 트리는 항상 N-1개의 간선을 가진다. 이는 이진 트리 뿐만 아니라 모든 트리의 특성이다. 루트 노드를 제외한 모든 자식 노드는 하나의 부모 노드와 연결되어 있기 때문에 전체 N개의 노드 중 루트 노드를 제외하면 결국 N-1개의 간선을 가지게 된다.
- 높이가 H인 이진 트리가 가질 수 있는 노드의 최소 개수는 H+1개이며 최대 개수는 2^(H+1)-1개이다. 각 깊이에 하나의 노드들이 존재하면 최소 개수가 되기 때문에 최소 개수는 곧 높이가 H일 때 H+1이 되고 0부터 시작하는 모든 깊이에 노드가 2개씩 가질 수 있기 때문에 최대 개수는 2^(H+1)-1이다. 최대 개수는 다시 말해 공비가 2인 등비수열의 합이다.

#### 종류

##### 포화 이진 트리(Full Binary Tree)

모든 깊이에 노드가 포화상태로 차 있는 이진 트리다.

다시 말해 높이가 H일 때 최대의 노드 개수인 2^(H+1)-1개의 노드를 가진 이진 트리다.

루트 노드를 1번으로 시작하여 좌측 자식 노드에게 먼저 숫자를 부여하여 모든 노드에 인덱스를 부여할 수 있다.

다시 말해 루트 노드의 인덱스는 1이며 단말 노드 중 가장 우측에 위치한 노드의 인덱스 번호는 노드의 최대 개수와 같기 때문에 높이가 H이라 할 때 2^(H+1)-1의 인덱스를 갖는다.

##### 완전 이진 트리(Complete Binary Tree)

높이가 H이고 노드 수가 N개 일 때 포화 이진 트리의 노드 번호 1번부터 N번까지 빈 자리 없이 연속된 이진 트리를 의미한다.

단, 이때 H+1 <= N < 2^(H+1)-1이다. 다시 말해 노드의 수는 해당 이진 트리가 가질 수 있는 최소 노드 개수보다 크거나 같고 최대 노드 개수보다 작아야 한다.

##### 편향 이진 트리(Skewed Binary Tree)

높이 H에 대해 최소 개수의 노드, 다시 말해 H+1개의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리다.

이때 모든 노드가 왼쪽 자식 노드만을 가진 편향 이진 트리를 왼쪽 편향 이진 트리라 하며 반대로 오른쪽 자식 노드만을 가진 편향 이진 트리를 오른쪽 편향 이진 트리라 한다.

### 실습

#### 문제

문자를 하나씩 입력 받아 리스트에 저장한 후, 스택 연산을 활용하여 입력 받은 문자의 역순 문자열을 생성하여 출력하는 프로그램을 작성하시오.

#### 조건

- 문자가 아닌 다른 값(숫자 등이)이 입력될 때까지 입력을 계속 받는다.
- 최종 출력 결과에서 리스트는 empty 상태가 되어야 한다.

#### 코드

```Python
import re


stack: list[str] = []
while re.match(
    r"[a-zA-Z]",
    (character := input("Input character: "))
):
    stack.append(character)

answer: str = ""
print(f"1 >>> {stack}")
for _ in range(len(stack)):
    answer += stack.pop()

print(f"2 >>> {stack}")
print(f"3 >>> {answer}")
```
